% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/EKOptimality.R
\name{EKOptimality}
\alias{EKOptimality}
\title{A dual utility function for optimal designs for prediction with estimated covariance and fixed effects parameters.}
\usage{
EKOptimality(ssn, glmssn, design.points, prior.parameters, n.draws,
  extra.arguments)
}
\arguments{
\item{ssn}{An object of class SpatialStreamNetwork}

\item{glmssn}{A fitted model object of class glmssn.}

\item{design.points}{A vector of pids corresponding to a set of observed sites in the obspoints slot of the SpatialStreamNetwork object.}

\item{prior.parameters}{A list of random functions that are parameterised in terms of n.draws.}

\item{n.draws}{A numeric scalar for the number of Monte Carlo draws to use when approximating the utility.}

\item{extra.arguments}{A list of extra parameters that control the behaviour of the utility function. The distance matrices required to compute covariance matrices are also stored in this list. Note that these are generated inside \code{\link{optimiseSSNDesign}}.}
}
\value{
A single number representing the expected utility for the design specified by \code{design.points}.
}
\description{
The function \code{EKoptimality} implements the EK-optimal utility function from Falk et al. (2014). This is appropriate for both optimal and adaptive design problems.

This function can be used with \code{\link{optimiseSSNDesign}}.
}
\details{
The utility function is

\deqn{U(d, \theta, y) = (\sum_{i = 1}^n Var(\hat{y}_i))^{-1}}{U(d, \theta, y) = SUM(VAR(\hat{Y}_i))}
 
That is, it is the inverse sum of the estimated kriging variances for a set of prediction sites with indices \eqn{i = 1, 2, ..., n}. 

A value of \code{-1e9} indicates a failure of this utility function.

One final note: do not worry about passing arguments to this function. All arguments are dealt with internally by \code{\link{optimiseSSNDesign}}.
}
\examples{

\dontrun{
# Create stream network
s <- createSSN(100, systematicDesign(0.25), systematicDesign(0.25), paste(tempdir(), "s.ssn", sep = "/"), TRUE)
createDistMat(s, "preds", TRUE, TRUE)

# Simulate data on network
s <- SimulateOnSSN(s, getSSNdata.frame(s), getSSNdata.frame(s, "preds"), "preds", formula = ~1, coefficients = 1, CorParms = c(1,2,1,2,1,2,0.1),addfunccol = "addfunccol")$ssn.object

# Fit a model to the simulated data
m <- glmssn(Sim_Values ~ 1, s, addfunccol = "addfunccol")

# Define the priors on the covariance parameters
p <- constructLogNormalCovPriors(m)

# Find the optimal design using D-optimality as the utility function
r <- optimiseSSNDesign(s, paste(tempdir(), "r.ssn", sep = "/"), m, 25, utility.function = EKOptimality, prior.parameters = p)

# Plot result to check
plot(r$ssn.new, "Sim_Values")
}
}
