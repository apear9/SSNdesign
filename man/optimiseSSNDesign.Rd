% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/optimiseSSNDesign.R
\name{optimiseSSNDesign}
\alias{optimiseSSNDesign}
\title{A function to optimise designs under pseudo-Bayesian utility functions using the Greedy Exchange Algorithm}
\usage{
optimiseSSNDesign(ssn, new.ssn.path, glmssn, n.points, legacy.sites,
  select.by = "auto", utility.function, prior.parameters, n.cores = 1,
  parallelism = "none", parallelism.seed = NULL, n.optim = 5,
  n.draws = 500, extra.arguments = list(), verbose = TRUE,
  record.designs = FALSE, ...)
}
\arguments{
\item{ssn}{An object of class SpatialStreamNetwork. This object must contain all potential sampling sites in its\code{obspoints} slot.}

\item{new.ssn.path}{A path to a folder where the result can be stored. The folder name must end in \code{.ssn}. This function will throw an error if the argument matches the name of an existing folder.}

\item{glmssn}{A fitted \code{glmssn} object. However, this model does not need to have been fitted to the \code{SpatialStreamNetwork} object in the argument ssn.}

\item{n.points}{A numeric or a named numeric vector specifying the size of the final design(s). See Details for more information.}

\item{legacy.sites}{A vector of the pids or locIDs of any 'legacy sites' which must appear in the final design. This argument is optional and should be left missing if not required. Note that the total number of sampling sites in the final design will still be \code{n.points}.}

\item{select.by}{A string argument which specifies whether each pid represents a single design point or each locID. The options are "auto" (the function will autodetect whether there are multiple pids per locID and use locIDs as unique design points), "pid" or "locID". This argument defaults to "auto".}

\item{utility.function}{A function with the signature 'utility.function'. See Details for more information.}

\item{prior.parameters}{A list of functions or a matrix. If this argument is a list, the elements of this list specify independent priors for the covariance parameters in the glmssn object. If this argument is a matrix, the matrix contains the prior draws from any kind of prior (multivariate or independent) on the covariance parameters in the \code{glmssn} object. Note, in this case, the \code{n.draws} argument will be ignored because the matrix will have as many rows as there are prior draws. See Details for more information.}

\item{n.cores}{The number of CPUs which should be used when running \code{optimiseSSNDesign}. This argument must agree with the argument \code{parallelism}. For example, this means that, if n.cores > 1 and \code{parallelism = "none"}, this argument will be ignored and all computations will be performed sequentially. Defaults to 1.}

\item{parallelism}{Must be one of "none", "windows", or "osx/linux". These arugments are insensitive to case. Note the argument must be selected appropriately for the operating system on the user's computer.}

\item{parallelism.seed}{Either a numeric integer or NULL. This argument can be used to seed a random number generator which ensures reproducible calculations. This argument is effective regardless of whether parallel computations are being used.}

\item{n.optim}{The number of times the Greedy Exchange Algorithm is iterated to find an optimal design. Any integer greater than or equal to 1 is permissible, though larger values will produce more reliable results. Defaults to 5.}

\item{n.draws}{The number of Monte Carlo draws used to approximate the expected utility from the utility function per Muller (1999). Any values larger than 1 are permitted, though a minimum of 100 are recommended for the most stable results.}

\item{extra.arguments}{A list of miscellaneous arguments and values which may be used to control the behaviour of the utility.function. See Details for more information.}

\item{verbose}{Whether messages indicating the function's progress should be printed to the console. Defaults to \code{TRUE}.}

\item{record.designs}{Whether the function should return all the designs evaluated. This is FALSE by default and should remain \code{FALSE} for larger examples due to the incredible amount of memory this requires.}

\item{...}{Any additional arguments for the \code{foreach} iterator. The version of \code{foreach} from the package \code{doRNG} is used.}
}
\value{
A list of four elements: 1) ssn.old, the original and unaltered ssn; 2) ssn.new, the original ssn modified such that it contains only the sites in the optimal design; 3) final.points, a vector of the locIDs or pids for the sampling sites present in the optimal design; and 4) utilities, a list of n.optim elements containing the expected utilities computed at every iteration of the Greedy Exchange Algorithm.
}
\description{
The function \code{optimiseSSNDesign} is the main workhorse function of the package \code{SSNdesign}. It works to construct optimal and adaptive designs using a greedy exchange algorithm under a variety of different circumstances.
}
\details{
There are several aspects of this function that require explanations beyond the brief descriptions of the arguments above. 
\itemize{
\item n.points: this argument can be a single number or a vector. If the user supplies a single number, then, regardless of the number of isolated networks present in the ssn object, a total of n.points sites will be selected across ALL these networks. That is, the networks are not treated as separate design problems. However, if the user supplies a vector, things become more complicated. Firstly, the vector must be named. The names of the elements correspond to networks in the ssn argument and the element itself is the number of sites which should be selected within that network. The n.points argument may therefore look like this: \code{c("1" = 5, "3" = 6)}. In this example, the user is asking for 5 sites to be chosen from network 1 and 6 from network 3. It also shows that there is no need to select sites in every network. One final caveat is that no sites will appear in ssn.new for any networks which are skipped over.
\item utility.function: there are a number of pre-defined utility functions such as \code{DOptimality} and \code{KOptimality}. See THIS PAGE for an exhaustive list. Instructions for creating user-defined utility functions can also be found through that link.
\item prior.parameters: the number of elements in the prior.parameters list must be the same as the number of covariance parameters in the fitted \code{glmssn} which is also passed to this function. For example, if the only covariance parameter is the nugget (i.e. there is no spatial autocorrelation), then prior.parameters would be a list with one element. Each list element must be structured as an anonymous function as follows: \code{prior.parameters[[i]] <- function(x) runif(x)}. The random sample function does not have to be \code{runif}. The key message is that the function must only have a single argument, which is the number of draws to be taken from a random sample function. The function \code{\link{constructLogNormalPriors}} is able to construct lists of log-normal priors from \code{glmssn} objects. 
\item extra.arguments: this is an argument that is mostly exploited internally by \code{optimiseSSNDesign}, since the list structure is convenient for storing myriad objects such as design and distance matrices involved in the computation of the expected utility. However, some utility functions, such as \code{CPOptimality}, have additional parameters that they expect from the extra.arguments list. In particular, \code{CPOptimality} expects extra.arguments$h, a step-size argument that it uses in the forward-finite differencing of the covariance matrix. (It needs to do this to estimate the expected Fisher information matrix, which the utility function relies on.)
}
}
\examples{

\dontrun{
## Simulate an ssn
s <- createSSN(c(100, 100), binomialDesign(c(25, 25)), path = paste(tempdir(), "s1.ssn", sep = "/"), importToR = TRUE)
createDistMat(s)
## Simulating data
s <- SimulateOnSSN(
 s, 
 getSSNdata.frame(s),
 formula = ~ 1, 
 coefficients = 1, 
 CorParms = c(1, 2, 1, 2, 1, 2, .1),
 addfunccol = "addfunccol"
)$ssn.object
## Model-fitting
m <- glmssn(Sim_Values ~ 1, s, addfunccol = "addfunccol")
## Construct a list of log-normal priors
p <- constructLogNormalPriors(m1)
## Use optimiseSSNDesign
r.together <- optimiseSSNDesign(
 ssn = s, new.ssn.path = paste(tempdir(), "s2.ssn", sep = "/"), glmssn = m, n.points = 25, 
 utility.function = DOptimality, prior.parameters = p, n.cores = 2, parallelism = "windows", 
parallelism.seed = 123, n.optim = 1, n.draws = 100)
r.apart <- optimiseSSNDesign(
 ssn = s, new.ssn.path = paste(tempdir(), "s3.ssn", sep = "/"), glmssn = m, n.points = c("1" = 7, "2" = 8), 
 utility.function = DOptimality, prior.parameters = p, n.cores = 2, parallelism = "windows", 
 parallelism.seed = 123, n.optim = 1, n.draws = 100)
}

}
\references{
Muller, P. (1999). Simulation Based Optimal Design. \emph{Bayesian Statistics}, \emph{6}, 1-13.
}
